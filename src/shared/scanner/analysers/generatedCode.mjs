// src/scanner/analysers/generatedCode.mjs
// Detection and exclusion of generated code files

import { readFileSync, existsSync } from 'fs';
import { basename, dirname } from 'path';

/**
 * Default patterns for generated code files
 * These files should be excluded from dead code analysis
 */
export const DEFAULT_GENERATED_PATTERNS = [
  // JavaScript/TypeScript
  /\.generated\.(ts|tsx|js|jsx|mjs)$/,
  /\.g\.(ts|js)$/,
  /\/generated\//,
  /\/__generated__\//,
  /\/codegen\//,

  // GraphQL
  /\/graphql\.(ts|tsx|js)$/,
  /\/gql\.(ts|tsx|js)$/,
  /\.graphql\.(ts|tsx|js)$/,
  /types\.generated\.(ts|tsx|js)$/,
  /\/__graphql__\//,

  // Protocol Buffers
  /_pb\.(js|d\.ts)$/,
  /_pb2\.py$/,
  /_pb2_grpc\.py$/,
  /\.pb\.(go|cc|h)$/,

  // OpenAPI/Swagger
  /\/api-client\//,
  /\/swagger-client\//,
  /\/openapi\/.*\.generated\./,

  // Java build outputs
  /\/target\/generated-sources\//,
  /\/target\/generated-test-sources\//,
  /\/build\/generated\//,
  /\/build\/generated-sources\//,
  /_\.java$/,  // MapStruct generated

  // .NET build outputs
  /\/obj\//,
  /\.Designer\.cs$/,
  /\.g\.cs$/,
  /\.g\.i\.cs$/,
  /\/Migrations\/.*\.cs$/,
  /^Migrations\/.*\.cs$/,           // Migrations at repo root (relative paths)
  /\.AssemblyAttributes\.cs$/,      // Auto-generated assembly attributes
  /GlobalSuppressions\.cs$/,        // Auto-generated code analysis suppressions

  // Go generated
  /_gen\.go$/,
  /mock_.*\.go$/,
  /.*_mock\.go$/,
  /\/mocks\/.*\.go$/,
  /_string\.go$/,  // stringer

  // Rust
  /\.rs\.bk$/,

  // Build outputs (all languages)
  /\/dist\//,
  /\/build\//,
  /\/out\//,
  /\/output\//,
  /\/.next\//,
  /\/.nuxt\//,
  /\/.output\//,
  /\/node_modules\//,
  /\/vendor\//,

  // Bazel outputs
  /\/bazel-bin\//,
  /\/bazel-out\//,
  /\/bazel-testlogs\//
];

/**
 * Header comments that indicate generated code
 */
const GENERATED_HEADERS = [
  /^\/\/ Code generated .* DO NOT EDIT/i,
  /^\/\/ AUTO-GENERATED/i,
  /^\/\/ GENERATED CODE/i,
  /^\/\/ This file was auto-?generated/i,
  /^# Generated by/i,
  /^# DO NOT EDIT/i,
  /^\s*\* @generated/,
  /^\/\*\s*eslint-disable\s*\*\//,  // Often in generated files
  /^\/\/ @ts-nocheck/,  // Often in generated files
  /@generated/,
  /DO NOT EDIT THIS FILE/i,
  /This file is auto-?generated/i,
  /Generated from /i
];

/**
 * Check if a file path matches generated code patterns
 * @param {string} filePath - File path to check
 * @param {RegExp[]} customPatterns - Additional patterns to check
 * @returns {Object} - { isGenerated: boolean, matchedPattern: string|null }
 */
export function isGeneratedPath(filePath, customPatterns = []) {
  const allPatterns = [...DEFAULT_GENERATED_PATTERNS, ...customPatterns];

  for (const pattern of allPatterns) {
    if (pattern.test(filePath)) {
      return {
        isGenerated: true,
        matchedPattern: pattern.toString(),
        reason: 'path'
      };
    }
  }

  return { isGenerated: false, matchedPattern: null };
}

/**
 * Check if file content indicates generated code (by header comments)
 * @param {string} content - File content
 * @param {number} linesToCheck - Number of lines to check from start (default 20)
 * @returns {Object} - { isGenerated: boolean, matchedPattern: string|null }
 */
export function isGeneratedContent(content, linesToCheck = 20) {
  if (!content) return { isGenerated: false };

  const lines = content.split('\n').slice(0, linesToCheck);
  const headerText = lines.join('\n');

  for (const pattern of GENERATED_HEADERS) {
    if (pattern.test(headerText)) {
      return {
        isGenerated: true,
        matchedPattern: pattern.toString(),
        reason: 'header'
      };
    }
  }

  return { isGenerated: false, matchedPattern: null };
}

/**
 * Check if a file is generated (by path or content)
 * @param {string} filePath - File path
 * @param {string} [content] - File content (optional, will be read if not provided)
 * @param {Object} options - Options
 * @returns {Object} - { isGenerated: boolean, reason: string|null }
 */
export function isGeneratedFile(filePath, content = null, options = {}) {
  const { customPatterns = [], checkContent = true } = options;

  // First check path
  const pathCheck = isGeneratedPath(filePath, customPatterns);
  if (pathCheck.isGenerated) {
    return pathCheck;
  }

  // Then check content if requested
  if (checkContent) {
    let fileContent = content;
    if (!fileContent && existsSync(filePath)) {
      try {
        fileContent = readFileSync(filePath, 'utf-8');
      } catch {
        // Can't read file, assume not generated
        return { isGenerated: false };
      }
    }

    if (fileContent) {
      const contentCheck = isGeneratedContent(fileContent);
      if (contentCheck.isGenerated) {
        return contentCheck;
      }
    }
  }

  return { isGenerated: false, reason: null };
}

/**
 * Filter out generated files from a list
 * @param {Array} files - Array of file objects with path/relativePath
 * @param {Object} options - Options
 * @returns {Object} - { included: Array, excluded: Array }
 */
export function filterGeneratedFiles(files, options = {}) {
  const included = [];
  const excluded = [];

  for (const file of files) {
    const filePath = file.relativePath || file.path || file;
    const content = file.content || null;

    const check = isGeneratedFile(filePath, content, options);
    if (check.isGenerated) {
      excluded.push({
        file: filePath,
        reason: check.reason,
        pattern: check.matchedPattern
      });
    } else {
      included.push(file);
    }
  }

  return { included, excluded };
}

/**
 * Get patterns for a specific codegen type
 * @param {string} type - Codegen type (graphql, protobuf, openapi, etc.)
 * @returns {RegExp[]} - Patterns for that type
 */
export function getPatternsForCodegenType(type) {
  const typePatterns = {
    graphql: [
      /\.graphql\.(ts|tsx|js)$/,
      /\/graphql\.(ts|tsx|js)$/,
      /\/gql\.(ts|tsx|js)$/,
      /types\.generated\.(ts|tsx|js)$/,
      /\/__generated__\//,
      /operations\.(ts|tsx|js)$/
    ],
    protobuf: [
      /_pb\.(js|d\.ts)$/,
      /_pb2\.py$/,
      /_pb2_grpc\.py$/,
      /\.pb\.(go|cc|h)$/,
      /\.pb\.ts$/
    ],
    openapi: [
      /\/api-client\//,
      /\/swagger-client\//,
      /\/openapi\/.*\.generated\./,
      /api\.generated\.(ts|js)$/
    ],
    thrift: [
      /_types\.(js|ts)$/,
      /\.thrift\.ts$/
    ],
    grpc: [
      /_grpc_pb\.(js|ts)$/,
      /_grpc\.pb\.go$/
    ]
  };

  return typePatterns[type] || [];
}

/**
 * Find codegen config files in a project
 * @param {string} projectPath - Path to project root
 * @param {Object} codegenConfigs - Config file patterns by type
 * @returns {Array} - Found config files
 */
export function findCodegenConfigs(projectPath, codegenConfigs = {}) {
  const defaults = {
    graphql: ['codegen.yml', 'codegen.yaml', 'codegen.ts', 'codegen.js', '.graphqlrc.yml', '.graphqlrc.json'],
    protobuf: ['buf.yaml', 'buf.gen.yaml', 'buf.work.yaml'],
    openapi: ['openapi.yaml', 'openapi.yml', 'openapi.json', 'swagger.yaml', 'swagger.json'],
    grpc: ['grpc-tools.config.js']
  };

  const configs = { ...defaults, ...codegenConfigs };
  const found = [];

  for (const [type, files] of Object.entries(configs)) {
    for (const file of files) {
      const fullPath = `${projectPath}/${file}`;
      if (existsSync(fullPath)) {
        found.push({
          type,
          file,
          path: fullPath
        });
      }
    }
  }

  return found;
}

export default {
  isGeneratedPath,
  isGeneratedContent,
  isGeneratedFile,
  filterGeneratedFiles,
  getPatternsForCodegenType,
  findCodegenConfigs,
  DEFAULT_GENERATED_PATTERNS
};
